---@diagnostic disable: undefined-global

local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")


local all_Pets = {}
local Huges_Hatched = {}
local All_Pets_Inventory = {}
local AllGameAreas = {}
local AdornedBoxes = {}
local UsedPets = {}
local UsedBreakables = {}
local activeBreakablesCount = 0
local pauseHatch = 999


local ServerCoins  = {}


local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")
local PlayerScripts = player:WaitForChild("PlayerScripts")
local Character = player.Character or player.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

local Safe_Part = Instance.new("Part")
Safe_Part.Anchored = true
Safe_Part.Size = Vector3.new(10,1,10)
Safe_Part.Parent = Workspace

Safe_Part.CFrame = HumanoidRootPart.CFrame - Vector3.new(0,5,0)


local MAX_BREAKABLES = 8
local RANGE = 200
local AutoFarmBreakables = false

local Auto_Teleport = false
local Teleportable_Breakables = {}

local Send_Webhook = false
local WebhookURL = ""
local UserID = 0
local AutoLoad = false

local __MAP = Workspace:WaitForChild("__MAP")


local All_Eggs_Available = {}
local All_Giant_Chest = {"Giant Relic Chest"}

local Selected_Egg = nil
local AutoHatch = false
local Auto_Convert_Gold = false
local Auto_Convert_Rainbow = false
local Auto_Convert_Dark_Matter = false

local Auto_Delete_Rarity = {}
local AutoDelete = false

local RemoveBreakables = false
local RemoveUselessStuff = false
local RemoveMap = false
local Rendering_Mode = false

local Giant_Chest_Selected = nil
local Auto_Farm_Giant = false

local Auto_Buy_Gems = false
local Auto_Progress = false

local Library = require(game:GetService("ReplicatedStorage").Library)
local Network = Library.Network
local PetCmds = require(ReplicatedStorage.Library.Client.PetCmds)
-- local PetNetworking = require(ReplicatedStorage.Library.Client.PetNetworking)

-- local CoinMutex = Library.Modules.Mutex.new()


-- Anti Cheat Bypass / game modification
hookfunction(debug.getupvalue(Library.Network.Invoke, 1), function(...) return true end)
hookfunction(debug.getupvalue(Library.Network.Fired, 1), function(...) return true end)

local banSuccess, banError = pcall(function()
	local Blunder = require(game:GetService("ReplicatedStorage"):WaitForChild("X", 10):WaitForChild("Blunder", 10):WaitForChild("BlunderList", 10))
	if not Blunder or not Blunder.getAndClear then player:Kick("Error while bypassing the anti-cheat! (Didn't find blunder)") end

	local OldGet = Blunder.getAndClear
	setreadonly(Blunder, false)
	local function OutputData(Message)
	   print("-- PET SIM X BLUNDER --")
	   print(Message .. "\n")
	end

	Blunder.getAndClear = function(...)
	   local Packet = ...
		for i,v in next, Packet.list do
		   if v.message ~= "PING" then
			   OutputData(v.message)
			   table.remove(Packet.list, i)
		   end
	   end
	   return OldGet(Packet)
	end
    
	setreadonly(Blunder, true)
end)
if not banSuccess then
	player:Kick("Error while bypassing the anti-cheat! (".. banError ..")")
	return
end
for i,v in pairs(getconnections(player.Idled)) do
	v:Disable()
end

local Data = Library.Save.Get()
local GamepassService = Library.Gamepasses
local Pets_Directory = Library.Directory.Pets
local Egg_Directory = Library.Directory.Eggs

local Coin_Directory = Library.Directory.Coins

_G.Library = Library

game:GetService("Players").LocalPlayer.PlayerScripts.Scripts.Game.Coins.Disabled = true
game:GetService("Players").LocalPlayer.PlayerScripts.Scripts.Game.Orbs.Disabled = true 
game:GetService("Players").LocalPlayer.PlayerScripts.Scripts.Game.Lootbags.Disabled = true
workspace.__THINGS.Coins:Destroy()
workspace.__THINGS.Orbs:Destroy()


for Name, coin in pairs(Coin_Directory) do
    if Name:find("Giant") and Name:find("Chest") then
        table.insert(All_Giant_Chest, Name)
    end
end

for egg, Egg_data in pairs(Egg_Directory) do
    table.insert(All_Eggs_Available, egg)
end

local function isHugePet(petId)
    if string.find(petId, "Huge") or string.find(petId, "Domortuus Astra") or string.find(petId, "Empyrean Agony") then
        return true
    end

    return false
end

function SendMessageWithEmbed(url, userId, embed)
    local http = game:GetService("HttpService")
    local headers = {
        ["Content-Type"] = "application/json"
    }
    local data = {
        ["embeds"] = {
            {
                ["title"] = embed.title,
                ["description"] = embed.description,
                ["color"] = embed.color,
                ["fields"] = embed.fields,
                ["footer"] = {
                    ["text"] = embed.footer.text
                }
            }
        }
    }
    local body = http:JSONEncode(data)
    local response = request({
        Url = url,
        Method = "POST",
        Headers = headers,
        Body = body
    })
    print("Sent")
end



for _, pet in pairs(Data.Pets) do
    if pet.id and isHugePet(pet.id) then
        table.insert(All_Pets_Inventory, pet.uid)
    end
end


Players.LocalPlayer.PlayerScripts.Scripts.Game["Open Eggs"].Disabled = true

local function OpenEgg(_, pets)
    if not Library.Variables.AutoDeleteEnabled then return end

    local save = Library.Save.Get()
    if not (save and save.AutoDelete) then return end

    local del = {}

    for _, p in pairs(pets) do
        if not p.uid then break end

        local ok, owner = Library.PetCmds.Get(p.uid)
        if not ok or owner ~= Library.LocalPlayer then break end

        local pet = Library.Directory.Pets[tostring(p.id)]
        if not pet then break end

        local mode = save.AutoDelete[tostring(pet.rarity)]
        if mode == 2 and not (p.g or p.r or p.dm)
        or mode == 3 and not (p.r or p.dm)
        or mode == 4 then
            table.insert(del, tostring(p.uid))
        end
    end

    if #del > 0 then
        Library.Network.Invoke("Delete Several Pets", del)
    end
end

Library.Network.Fired("Open Egg"):Connect(function(a, b)
    Library.Network.Fire("Opening Egg", a, b)
    OpenEgg(a, b)
end)



for name, area in pairs(Library.Directory.Areas) do
	local world = Library.Directory.Worlds[area.world]
	if world and world.worldOrder and world.worldOrder > 0 then
		if not area.hidden and not area.isVIP then
			local containsArea = false
			if world.spawns then
				for i,v in pairs(world.spawns) do
					if v.settings and v.settings.area and v.settings.area == name then 
						containsArea = true 
						break 
					end
				end
			end
			
			if area.gate or containsArea then
				table.insert(AllGameAreas, name)
			end
		end
	end
end


table.sort(AllGameAreas, function(a, b)
	local areaA = Library.Directory.Areas[a]
	local areaB = Library.Directory.Areas[b]
	local worldA = Library.Directory.Worlds[areaA.world]
	if a == "Ice Tech" then 
		worldA = Library.Directory.Worlds["Fantasy"]
	end
	
	local worldB = Library.Directory.Worlds[areaB.world]
	if b == "Ice Tech" then 
		worldB = Library.Directory.Worlds["Fantasy"]
	end
	if worldA.worldOrder ~= worldB.worldOrder then
		return worldA.worldOrder < worldB.worldOrder
	end
	
	local currencyA = Library.Directory.Currency[worldA.mainCurrency]
	local currencyB = Library.Directory.Currency[worldB.mainCurrency]
	if currencyA.order ~= currencyB.order then
		return currencyA.order < currencyB.order
	end
	
	if not areaA.gate or not areaB.gate then
		return areaA.id < areaB.id
	end
	
	return areaA.gate.cost < areaB.gate.cost
end)






local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Pet Simulator X Overhauled",
   Icon = 0,
   LoadingTitle = "Pet Simulator X Overhauled",
   LoadingSubtitle = "by Paule",
   ShowText = "Rayfield",
   Theme = "Ocean",

})

local Hatching_Tab = Window:CreateTab("Hatching", "egg")
local Pet_Tab = Window:CreateTab("Pet", "cat")
local autoFarmTab = Window:CreateTab("Auto Farm", "egg")


local Egg_Selection = Hatching_Tab:CreateDropdown({
   Name = "Select Egg",
   Options = All_Eggs_Available,
   CurrentOption = {},
   MultipleOptions = false,
   Flag = "EggSelection",
   Callback = function(Options)
        for _, Option in pairs(Options) do
            Selected_Egg = Option
        end
   end,
})


local AutoHatchToggle = Hatching_Tab:CreateToggle({
    Name = "Start Hatching",
    CurrentValue = false,
    Flag = "HatchToggle",
    Callback = function(Value)
        AutoHatch = Value

        task.spawn(function()
            while AutoHatch do
                task.wait(0.2)
                
                if #Data.Pets >= pauseHatch then
                    wait(0.5)
                    continue
                end
                if not Selected_Egg then 
                    wait(0.5)
                    continue
                end
                task.spawn(function()
                    local Data = Library.Save.Get()
                    if Data and  Selected_Egg then
                        -- Network.Invoke("Buy Egg", Selected_Egg, Data.EggSlots)
                        -- Network.Invoke("Buy Egg", Selected_Egg, false,false)
                        -- Network.Invoke("Buy Egg", Selected_Egg, true,false)
                        -- Network.Invoke("Buy Egg", Selected_Egg, false,true)
                        Network.Invoke(
                            "Buy Egg",
                            Selected_Egg,
                            Data.OwnGamepass["Triple Egg Open"] or false
                        )
                    else
                        print("No egg selected or egg slots not available.")
                    end
                end)
            end
        end)
    end,
})

local MaxInventoryStop = Hatching_Tab:CreateSlider({
	Name = "Pauses when inventory hits",
	Range = {0, 999},
	Increment = 1,
	Suffix = "Pets",
	CurrentValue = pauseHatch,
	Flag = "MaxBreakablesSlider",
	Callback = function(Value)
		pauseHatch = Value
	end,
})

local Input = Hatching_Tab:CreateInput({
   Name = "Pauses when inventory hits",
   CurrentValue = tostring(pauseHatch),
   PlaceholderText = tostring(pauseHatch),
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
        pauseHatch = tonumber(Text)
        MaxInventoryStop:Set(tonumber(pauseHatch)) 
   end,
})


local Section = Hatching_Tab:CreateSection("Huge Webhook Notifications")
local WebhookURLINPUT = Hatching_Tab:CreateInput({
   Name = "Input Webhook URL",
   CurrentValue = "",
   PlaceholderText = "Input Placeholder",
   RemoveTextAfterFocusLost = false,
   Flag = "WebhookInputURL",
   Callback = function(Text)
        WebhookURL = Text
   end,
})

local WEBhookUSERIDInput = Hatching_Tab:CreateInput({
   Name = "Discord UserID",
   CurrentValue = "",
   PlaceholderText = "",
   RemoveTextAfterFocusLost = false,
   Flag = "WebhookInputUserID",
   Callback = function(Text)
        UserID = Text
   end,
})

local function formatNumber(n)
    local absN = math.abs(n)
    if absN >= 1e9 then
        return string.format("%.2fB", n / 1e9)
    elseif absN >= 1e6 then
        return string.format("%.2fM", n / 1e6)
    elseif absN >= 1e3 then
        return string.format("%.2fK", n / 1e3)
    else
        return tostring(n)
    end
end


local SendWEbhooktoogle = Hatching_Tab:CreateToggle({
    Name = "Send Huge Pet Notifications",
    CurrentValue = false,
    Flag = "WebhookToggle",
    Callback = function(Value)
        Send_Webhook = Value
        if Send_Webhook then
            task.spawn(function()
                while Send_Webhook do
                    task.wait(1)
                    Data = Library.Save.Get()
                    for _, pet in pairs(Data.Pets) do
                        if pet["id"] and isHugePet(pet["id"]) and not table.find(All_Pets_Inventory, pet.uid) then
                            table.insert(Huges_Hatched, pet.uid)
                            table.insert(All_Pets_Inventory, pet.uid)
                            local baseName = Pets_Directory[pet.id].name or "Unknown Pet"
                            local variants = {}
                            if pet.g then table.insert(variants, "Golden") end
                            if pet.r then table.insert(variants, "Rainbow") end
                            if pet.dm then table.insert(variants, "Dark Matter") end
                            if pet.hc then table.insert(variants, "Hardcore") end

                            local variantStr = (#variants > 0) and (table.concat(variants, " ") .. " ") or ""
                            local petName = variantStr .. baseName


                            local message = string.format("Huge Pet Hatched: %s", petName)

                            if WebhookURL ~= "" then

                                local embed = {
                                    title = "Huge Pet Hatched",
                                    description = message,
                                    color = 8388736,
                                    fields = {
                                        {
                                                name = "Username",
                                                value = player.Name
                                        },
                                        {
                                                name = "Total Eggs Hatched",
                                                value = tostring(formatNumber(Data.EggsOpened[Selected_Egg] or 0)),
                                        },
                                        {
                                                name = "Total Huges Hatched",
                                                value = tostring(#Huges_Hatched) or 0
                                        },
                                        {
                                                name = "Total Huges",
                                                value = #All_Pets_Inventory or 0
                                        },
                                        {
                                                name = "Diamonds",
                                                value = tostring(formatNumber(Data.Diamonds) or 0)
                                        }
                                    },
                                    footer = {
                                        text = "Pet Simulator X Overhauled"
                                    }
                                }
                                SendMessageWithEmbed(WebhookURL,UserID,embed)
                            end
                        end
                    end
                end
            end)
        end
    end,
})


local AutoConverGoldToggle = Pet_Tab:CreateToggle({
    Name = "Auto Make Gold",
    CurrentValue = false,
    Flag = "AutoConvertGold",
    Callback = function(Value)
        Data = Library.Save.Get()
        Auto_Convert_Gold = Value
        if Auto_Convert_Gold and Data then
            task.spawn(function()
                while Auto_Convert_Gold do
                    Data = Library.Save.Get()
                    task.wait()
                    local normalPetsById = {}
                    for _, pet in pairs(Data.Pets) do
                        if not pet.r and not pet.g and not pet.dm and not isHugePet(pet.id) then
                            normalPetsById[pet.id] = normalPetsById[pet.id] or {}
                            table.insert(normalPetsById[pet.id], pet)
                        end
                    end
                    for petId, pets in pairs(normalPetsById) do
                        print(#pets)
                        if #pets <= 5 then
                            continue
                        end
                        local petsToConvert = {}
                        for i = 1, 6 do
                            table.insert(petsToConvert, pets[i].uid)
                        end
                        Network.Invoke("Use Golden Machine", petsToConvert)
                        for _, petUid in ipairs(petsToConvert) do
                            for _, pet in ipairs(pets) do
                                if pet.uid == petUid then
                                    break
                                end
                            end
                        end
                        for i = 6, 1, -1 do
                            table.remove(pets, i)
                        end
                        task.wait()
                        break
                    end
                    task.wait()
                end
            end)
        end
    end,
})

local ToggleRainbow = Pet_Tab:CreateToggle({
    Name = "Auto Make Rainbow",
    CurrentValue = false,
    Flag = "AutoConvertRainbow",
    Callback = function(Value)
        Data = Library.Save.Get()
        Auto_Convert_Rainbow = Value
        if Auto_Convert_Rainbow and Data then
            task.spawn(function()
                while Auto_Convert_Rainbow do
                    Data = Library.Save.Get()
                    task.wait()
                    local goldPetsById = {}
                    for _, pet in pairs(Data.Pets) do
                        if pet.g and not pet.r and not pet.dm and not isHugePet(pet.id) then
                            goldPetsById[pet.id] = goldPetsById[pet.id] or {}
                            table.insert(goldPetsById[pet.id], pet)
                        end
                    end
                    for petId, pets in pairs(goldPetsById) do
                        if #pets <= 5 then
                            continue
                        end
                        local petsToConvert = {}
                        for i = 1, 6 do
                            table.insert(petsToConvert, pets[i].uid)
                        end
                        Network.Invoke("Use Rainbow Machine", petsToConvert)
                        print("Bereit zum Rainbow machen:", petId, petsToConvert)
                        for _, petUid in ipairs(petsToConvert) do
                            for _, pet in ipairs(pets) do
                                if pet.uid == petUid then
                                    break
                                end
                            end
                        end
                        for i = 6, 1, -1 do
                            table.remove(pets, i)
                        end
                        task.wait()
                        break
                        -- end
                    end
                    task.wait()
                end
            end)
        end
    end,
})

local ToggleDarkMatter = Pet_Tab:CreateToggle({
    Name = "Auto Make Dark Matter",
    CurrentValue = false,
    Flag = "",
    Callback = function(Value)
        Data = Library.Save.Get()
        Auto_Convert_Dark_Matter = Value
        if Auto_Convert_Dark_Matter and Data then
            task.spawn(function()
                while Auto_Convert_Dark_Matter do
                    Data = Library.Save.Get()
                    task.wait()
                    local rainbowPetsById = {}
                    for _, pet in pairs(Data.Pets) do
                        if pet.r and not pet.dm and not pet.g then
                            rainbowPetsById[pet.id] = rainbowPetsById[pet.id] or {}
                            table.insert(rainbowPetsById[pet.id], pet)
                        end
                    end
                    for petId, pets in pairs(rainbowPetsById) do
                        while #pets >= 1 do
                            local petsToConvert = {}
                            for i = 1, 1 do
                                table.insert(petsToConvert, pets[i].uid)
                            end
                            Network.Invoke("Dark Matter Machine: Use", petsToConvert)
                            for _, petUid in ipairs(petsToConvert) do
                                for _, pet in ipairs(pets) do
                                    if pet.uid == petUid then
                                        break
                                    end
                                end
                            end
                            for i = 1, 1, -1 do
                                table.remove(pets, i)
                            end
                            task.wait(1)
                        end
                    end
                    task.wait()
                end
            end)
        end
    end,
})

local Section = Pet_Tab:CreateSection("Better Auto Delete")



local AutoDeleteSelection = Pet_Tab:CreateDropdown({
   Name = "Auto Delete Rarity",
   Options = {"Basic", "Epic", "Rare", "Legendary", "Event"},
   CurrentOption = {},
   MultipleOptions = true,
   Flag = "AutoDeleteRarity",
   Callback = function(Options)
        Auto_Delete_Rarity = {}
        for _, Option in pairs(Options) do
            table.insert(Auto_Delete_Rarity, Option)
        end
    end
})

local AutoDeletePEtstoggle = Pet_Tab:CreateToggle({
    Name = "Auto Delete Pets",
    CurrentValue = false,
    Flag = "AutoDeletePEtstoggle",
    Callback = function(Value)
        AutoDelete = Value
        if AutoDelete then
            task.spawn(function()
                while AutoDelete do
                    task.wait(0.1)
                    local pets_to_delete = {}
                    local Data = Library.Save.Get()

                    for _, petData in pairs(Data.Pets) do
                        local petInfo = Pets_Directory[petData.id]
                        if not petInfo then continue end

                        local rarity = petInfo.rarity
                        local isHuge = isHugePet(petData.id)
                        local isEvent = rarity == "Event"
                        local isRainbow = petData.r
                        local isDarkMatter = petData.dm

                        if isHuge then continue end

                        if isEvent and (isRainbow or isDarkMatter) then
                            continue
                        end

                        if table.find(Auto_Delete_Rarity, rarity) then
                            table.insert(pets_to_delete, petData.uid)
                        end
                    end

                    if #pets_to_delete > 0 then
                        Network.Invoke("Delete Several Pets", pets_to_delete)
                    end
                end
            end)
        end
    end
})


local LootbagsFolder = Library.Things.Lootbags

local function InstantCollect(id, pos, isBoost, boostData)
    Network.Fire("Collect Lootbag", id, pos)
    
    if isBoost and boostData then
        Library.Signal.Fire("Rewards Redeemed", {{boostData[1], boostData[2]}})
    end
end



Library.Network.Fired("Orb Added"):Connect(function(id, data)
    Library.Network.Fire("Claim Orbs", {id})
end)

Network.Fired("Spawn Lootbag"):Connect(function(id, data)
    local isBoost = (data.reward and data.reward[1] == "Boost")
    local boostData = isBoost and {data.reward[3], data.reward[2]} or nil
    
    InstantCollect(id, data.position, isBoost, boostData)
end)

for _, bag in ipairs(LootbagsFolder:GetChildren()) do
    local id = bag:GetAttribute("ID") or bag.Name
    Network.Fire("Collect Lootbag", id, bag.CFrame.Position)
    bag:Destroy()
end
LootbagsFolder:Destroy()
-- Utils


local function isInRange(vec3)
	return (vec3 - HumanoidRootPart.Position).Magnitude <= RANGE
end


local ServerCoins = {}

local function DestroyCoinPart(id)
    local p = workspace:FindFirstChild(tostring(id))
    if p then
        p:Destroy()
    end
end

local function RemoveCoin(id)
    assert(typeof(id) == "string", "ID muss ein String sein")
    
    ServerCoins[id] = nil
    
    DestroyCoinPart(id)
end

local function AddCoin(id, data)
    local pos = data and (data.p or data.position or data.Position)
    if not id or not pos then return end
    
    ServerCoins[id] = data
    

    if not workspace:FindFirstChild(id) then
        local p = Instance.new("Part")
        p.Name = id
        p.Anchored = true
        p.CanCollide = false
        p.Position = (typeof(pos) == "Vector3" and pos) or Vector3.new(pos.x, pos.y, pos.z)
        p.Parent = workspace
        p.Size = Vector3.new(5,5,5)
    end
end

local function LoadAllCoinsInternal()
    local coins = Library.Network.Invoke("Get Coins")
    if not coins then
        return warn("Coins konnten nicht geladen werden (nil)")
    end

    for id, data in pairs(coins) do
        AddCoin(id, data)
    end

    for id in pairs(ServerCoins) do
        if not coins[id] then
            RemoveCoin(id)
        end
    end
end

Library.Network.Fired("Remove Coin"):Connect(RemoveCoin)
Library.Network.Fired("Add Coin"):Connect(AddCoin)

task.spawn(function()
    while true do
        LoadAllCoinsInternal()
        task.wait(1)
    end
end)
task.spawn(function()
    while true do
        task.wait(30)
        collectgarbage(tostring("count"))
        gcinfo()
    end
end)


task.spawn(function()
    -- UI: Sliders and Toggle
local MaxBreakablesSlider = autoFarmTab:CreateSlider({
	Name = "Max Breakables",
	Range = {0, 15},
	Increment = 1,
	Suffix = "Breakables",
	CurrentValue = MAX_BREAKABLES,
	Flag = "MaxBreakablesSlider",
	Callback = function(Value)
		MAX_BREAKABLES = Value
	end,
})

local SliderRange = autoFarmTab:CreateSlider({
	Name = "Range",
	Range = {0, 300},
	Increment = 10,
	Suffix = "Studs",
	CurrentValue = RANGE,
	Flag = "RangeSlider",
	Callback = function(Value)
		RANGE = Value
	end,
})

end)

local BreakablesFolder = {}


task.wait(0.5)

local equippedPets = {}
local validTargets = {}

local function clear(t)
	table.clear(t)
end

local AutoFarmBreakablesToggle = autoFarmTab:CreateToggle({
	Name = "Auto Farm Breakables",
	CurrentValue = false,
	Flag = "AutoFarmBreakables",
	Callback = function(Value)
		AutoFarmBreakables = Value
		if AutoFarmBreakables then
            task.spawn(function()
                
                local FarmOnlyDiamonds = false 
                
                while AutoFarmBreakables do
                    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
                        task.wait(0.5) 
                        continue
                    end
                    HumanoidRootPart = player.Character.HumanoidRootPart

                    local equippedPets = {}
                    for euid, petDta in pairs(PetCmds.GetEquipped()) do
                        table.insert(equippedPets, petDta.uid)
                    end
                    
                    if #equippedPets > 0 then
                        local validTargets = {}

                        for id, coin in pairs(ServerCoins) do
                            if coin.p and (coin.p - HumanoidRootPart.Position).Magnitude <= RANGE then
                                local isDiamond = false
                                if coin.n then
                                    isDiamond = coin.n:lower():find("diamond") ~= nil
                                end
                                
                                if not FarmOnlyDiamonds or isDiamond then                                    
                                    table.insert(validTargets, {
                                        id = id,
                                        p = coin.p,
                                        distance = (coin.p - HumanoidRootPart.Position).Magnitude
                                    })
                                end
                            end
                        end
                        for id, coin in pairs(ServerCoins) do
                        	local marker = workspace:FindFirstChild(id)
                        	if marker then
                        		local isValid = false
                        		for _, t in ipairs(validTargets) do
                        			if t.id == id then
                        				isValid = true
                        				break
                        			end
                        		end
                        		marker.Color = isValid and Color3.fromRGB(0, 102, 255) or Color3.fromRGB(255, 0, 0)
                        	end
                        end


                        table.sort(validTargets, function(a, b)
                            return a.distance < b.distance
                        end)
                        
                        if #validTargets == 0 then
                            for id, coin in pairs(ServerCoins) do
                                if coin.p and (coin.p - HumanoidRootPart.Position).Magnitude <= RANGE then
                                    table.insert(validTargets, {id = id, p = coin.p})
                                end
                            end
                        
                            table.sort(validTargets, function(a, b)
                                return (a.p - HumanoidRootPart.Position).Magnitude < (b.p - HumanoidRootPart.Position).Magnitude
                            end)
                        end
                        local targetLimit = math.min(#validTargets, MAX_BREAKABLES)
                        if targetLimit > 0 then
                            for i, petUID in ipairs(equippedPets) do
                            	local target = validTargets[((i - 1) % targetLimit) + 1]
                            	if target then
                            		task.spawn(function()
                            			local marker = workspace:FindFirstChild(target.id)
                            			if marker then
                            				marker.Color = Color3.fromRGB(132, 0, 255)
                            			end
                                    
                            			Network.Invoke("Join Coin", target.id, { petUID })
                            			Network.Fire("Farm Coin", target.id, petUID)
                            		end)
                            	end
                            end

                        end
                    end
                    

                    task.wait(0.1)
                    validTargets = {}
                end
            end)
		end
	end,
})


local Section = autoFarmTab:CreateSection("Auto Farm Giant Chest")

local Giant_Chest_Select = autoFarmTab:CreateDropdown({
   Name = "Select Giant Chest",
   Options = All_Giant_Chest,
   CurrentOption = {},
   MultipleOptions = false,
   Flag = "Dropdown1",
   Callback = function(Options)
        Giant_Chest_Selected = nil
        for _, Option in pairs(Options) do
            Giant_Chest_Selected = Option
            print(Giant_Chest_Selected, Option)
        end
   end,
})

local Auto_Farm_Chest_Toggle = autoFarmTab:CreateToggle({
   Name = "Auto Farm Giant",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
        Auto_Farm_Giant = Value
        print(Auto_Farm_Giant, Giant_Chest_Selected)
        if Auto_Farm_Giant and Giant_Chest_Selected ~= nil then
            task.spawn(function()
                while Auto_Farm_Giant do
                    task.wait()
					
					local all_Pets = {}
					for _, petData in pairs(require(ReplicatedStorage.Library.Client.PetCmds).GetEquipped()) do
						table.insert(all_Pets, petData.uid)
					end

					local targetBreakable = nil

                    for id, coin in pairs(ServerCoins) do
                        if coin.n == Giant_Chest_Selected then
                            targetBreakable = coin
                            Safe_Part.CFrame = CFrame.new(coin.p) - Vector3.new(0,5,0)
                            HumanoidRootPart.CFrame = CFrame.new(coin.p)
                            break
                        end
                    end

                    if targetBreakable and ServerCoins and ServerCoins[targetBreakable.Name] then
						local breakableID = targetBreakable.Name
						Network.Invoke("Join Coin", breakableID, all_Pets)
						task.wait(0.1)
						for _, pet in ipairs(all_Pets) do
							Network.Fire("Change Pet Target", pet, "Coin", breakableID)
							task.wait()
							Network.Fire("Farm Coin", breakableID, pet)
						end

                        while targetBreakable and ServerCoins and ServerCoins[breakableID] do
                            Network.Invoke("Join Coin", breakableID, all_Pets)
							task.wait(0.1)
							for _, pet in ipairs(all_Pets) do
								Network.Fire("Change Pet Target", pet, "Coin", breakableID)
								task.wait()
								Network.Fire("Farm Coin", breakableID, pet)
							end
                        end
					end
                end
            end)
        end
   end,
})


local Section = autoFarmTab:CreateSection("Auto Teleport")
local priorityList = {
	"Diamond Crate",
	"Diamond Present",
	"Diamonds",
    "Chest",
    "Vault",
    "Safe",
    "Crate",
    "Present",
}

local Teleportable_Breakables = {}

local Teleportable_Breakables_Dropdown = autoFarmTab:CreateDropdown({
    Name = "Breakables to Teleport to",
    Options = priorityList,
    CurrentOption = {},
    MultipleOptions = true,
    Flag = "Dropdown1",
    Callback = function(Options)
        Teleportable_Breakables = {}
        for _, Option in pairs(Options) do
            table.insert(Teleportable_Breakables, Option)
        end
    end,
})

local AutoTeleportToBreakables = autoFarmTab:CreateToggle({
    Name = "Auto Teleport",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        Auto_Teleport = Value
        if not Value then return end

        task.spawn(function()
            repeat task.wait() until AutoFarmBreakables

            while Auto_Teleport do
                local teleported = false
                for _, prioName in ipairs(priorityList) do
                    if table.find(Teleportable_Breakables, prioName) then
                        for _, breakable in pairs(ServerCoins) do
                            local nameAttr = breakable.n
                            local AreaAttr = breakable.a
                            if breakable.p
                                and nameAttr
                                and table.find(Data["AreasUnlocked"], AreaAttr)
                                and nameAttr:lower():find(prioName:lower())
                                and nameAttr ~= "Giant Diamond Chest"
                                and nameAttr ~= "Giant Tech Chest" then

                                HumanoidRootPart.CFrame = CFrame.new(breakable.p)
                                Safe_Part.CFrame = CFrame.new(breakable.p) - Vector3.new(0,5.0)
                                repeat task.wait()
                                until not ServerCoins[breakable.id] or not isInRange(breakable.p)

                                teleported = true
                                break
                            end
                        end
                        if teleported then break end
                    end
                end
                task.wait()
            end

        end)
    end,
})


local Section = autoFarmTab:CreateSection("Misc")

local Auto_Buy_Gems_Toggle = autoFarmTab:CreateToggle({
   Name = "Auto Buy Gems (1,25m)",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
        Auto_Buy_Gems = Value
        if Auto_Buy_Gems then
            task.spawn(function()
                while Auto_Buy_Gems do
                    Network.Invoke("Buy Diamonds", 4)
                    task.wait(1)
                end
            end)
        end
   end,
})



local Tab = Window:CreateTab("Optimizer", "rewind")

local Remove_Useless_Stuff = Tab:CreateToggle({
   Name = "Remove Useless Stuff",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
        RemoveUselessStuff = Value
        if RemoveUselessStuff then
           if Workspace:FindFirstChild("__DEBRIS") then
                Workspace:FindFirstChild("__DEBRIS"):Destroy()
           end
           if __MAP.Areas:FindFirstChild("ALWAYS RENDERED") then
                __MAP.Areas:FindFirstChild("ALWAYS RENDERED"):Destroy()
           end
        end
   end,
})


local Remove_Map= Tab:CreateToggle({
   Name = "Remove Map",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
        RemoveMap = Value
        __MAP = Workspace:WaitForChild("__MAP")
        if RemoveMap then
            for _, Area in ipairs(__MAP.Areas:GetChildren()) do
                for _, AreaElement in ipairs(Area:GetChildren()) do
                    if AreaElement.Name ~= "Ground" and AreaElement.Name ~= "GROUND" then
                        AreaElement:Destroy()
                    end
                end
            end
        end
   end,
})

local Remove_Map_All= Tab:CreateToggle({
   Name = "Remove Map (All)",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
        RemoveMapAll = Value
        __MAP = Workspace:WaitForChild("__MAP")
        if RemoveMapAll and __MAP then
            __MAP:Destroy()
            setfpscap(20)
        end
   end,
})
